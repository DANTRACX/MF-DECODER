/*======================================================================*
 * PROJECT:         MF-DECODER
 * MODUL:           MM-PROTOCOL
 * DEVELOPED BY:    Christoph Klie
 * FILENAME:        mm_protocol.c
 *
 * DESCRIPTION:
 *      MM-PROTOCOL SOURCE FILE
 *      THIS MODULE READS, FILTERS AND CONVERTS MOTOROLA DATA FRAMES FOR THE
 *      USER. (SWITCHES ONLY, TRAIN COMMANDS WILL BE FILTERED OUT)
 *      FOR MOTOROLA I AND MOTOROLA II
 *
 * (C) COPYRIGHT 2015 - CHRISTOPH KLIE
 *======================================================================*/

#include "mm_protocol.h"

/*
 * BASIC MOTOROLA PHYSICAL SETTINGS
 */
#define MM_SWITCH_BIT_LENGTH                        104UL
#define MM_SWITCH_BIT_SAMPLE_INTERVALL              ((MM_AVR_SPEED / 1000000UL) * ((MM_SWITCH_BIT_LENGTH * 1) / 2))
#define MM_SWITCH_BIT_OVERSIZE_DETECT_INTERVALL     ((MM_AVR_SPEED / 1000000UL) * ((MM_SWITCH_BIT_LENGTH * 5) / 3))

#define MM_SWITCH_IDLE_LENGTH                       2100UL
#define MM_SWITCH_IDLE_POLARITY_DETECT_INTERVALL    ((MM_AVR_SPEED / 1000000UL) * ((MM_SWITCH_IDLE_LENGTH * 4) / 5))

/*
 * DATATYPE FOR MOTOROLA PURPOSES
 */
struct MM_t
{
    volatile unsigned char POLARITY;
    volatile unsigned char BITCOUNT;
    volatile unsigned char BYTECOUNT;
    volatile unsigned char TMPBYTE;
    volatile unsigned char MESSAGE[3];
    volatile unsigned char MESSAGESIZE;
}
MM;

/*
 * INTERRUPT FUNCTION PROTOTYPES
 */
static void MM_INTERRUPT_IDLE_ACTIVITY_DETECTION();
static void MM_INTERRUPT_IDLE_POLARITY_DETECTION();
static void MM_INTERRUPT_BIT_DETECTION();
static void MM_INTERRUPT_BIT_SAMPLE_AND_SAVE();
static void MM_INTERRUPT_BIT_SAMPLE_AND_VERIFY();
static void MM_INTERRUPT_BIT_OVERSIZED();

/*
 * MACRO FUNCTION FOR SETTING INTERFACE TO IDLE MODE
 */
__attribute__((always_inline))
static inline void MM_IDLE_MODE()
{
    __IO_DRIVER_INTERRUPT_INT0_SETFUNC(MM_INTERRUPT_IDLE_ACTIVITY_DETECTION);

    __TIMER1_DRIVER_TCNT = 0x0000;
    __TIMER1_DRIVER_INTERRUPT_COMPA_SETFUNC(MM_INTERRUPT_IDLE_POLARITY_DETECTION);
    __TIMER1_DRIVER_INTERRUPT_COMPA_UPDATE((unsigned short)MM_SWITCH_IDLE_POLARITY_DETECT_INTERVALL);
    __TIMER1_DRIVER_INTERRUPT_COMPB_UPDATE((unsigned short)0xFFFF);
    __TIMER1_DRIVER_CLOCK_DIV1();
}

/*
 * INITIALIZE THE MOTOROLA INTERFACE AND START DETECTION
 */
void MM_INITIALIZE(void)
{
    MM.BITCOUNT = 0;
    MM.BYTECOUNT = 0;
    MM.MESSAGESIZE = 0;
    MM.TMPBYTE = 0x00;
    MM.POLARITY = 0x00;

    __TIMER1_DRIVER_MODE_NORMAL();
    __TIMER1_DRIVER_INTERRUPT_COMPA_SETFUNC(MM_INTERRUPT_IDLE_POLARITY_DETECTION);
    __TIMER1_DRIVER_INTERRUPT_COMPB_SETFUNC(MM_INTERRUPT_BIT_OVERSIZED);
    __IO_DRIVER_INTERRUPT_INT0_SETFUNC(MM_INTERRUPT_IDLE_ACTIVITY_DETECTION);
    __IO_DRIVER_INTERRUPT_INT0_SENSE_RISING();
    __IO_DRIVER_INTERRUPT_INT0_ENABLE();
    __TIMER1_DRIVER_INTERRUPT_COMPA_ENABLE((unsigned short)MM_SWITCH_IDLE_POLARITY_DETECT_INTERVALL);
    __TIMER1_DRIVER_INTERRUPT_COMPB_ENABLE((unsigned short)0xFFFF);

    MM_IDLE_MODE();
}

/*
 * DISABLE MOTOROLA INTERFACE
 */
void MM_DEINITIALIZE(void)
{
    __TIMER1_DRIVER_CLOCK_OFF();
    __IO_DRIVER_INTERRUPT_INT0_DISABLE();
    __TIMER1_DRIVER_INTERRUPT_COMPA_DISABLE();
    __TIMER1_DRIVER_INTERRUPT_COMPB_DISABLE();
    MM.MESSAGESIZE = 0x00;
}

/*
 * CHECK FOR NEW MOTOROLA MESSAGES AND FILTER WRONG FORMAT
 */
unsigned char MM_FETCH(unsigned short *MM_DATA_FRAME)
{
    if(MM.MESSAGESIZE == 0)
    {
        return 0;
    }

    if(((MM.MESSAGE[1] & 0x0F) == 0x00) && ((MM.MESSAGE[2] & 0x3F) == 0x00))
    {
        /* TURN OFF COMMAND FOR COMPLETE DECODER ADDRESS FILTERED OUT */
        MM.MESSAGESIZE = 0;
        return 0;
    }

    if((MM.MESSAGE[1] & 0x0C) == 0x00)
    {
        *MM_DATA_FRAME = (unsigned short)(MM.MESSAGE[0] & 0x3F);
        *MM_DATA_FRAME <<= 6;
        *MM_DATA_FRAME |= (unsigned short)(MM.MESSAGE[1] & 0x30);
        *MM_DATA_FRAME >>= 2;
        *MM_DATA_FRAME |= (unsigned short)(MM.MESSAGE[1] & 0x03);
        *MM_DATA_FRAME <<= 6;
        *MM_DATA_FRAME |= (unsigned short)(MM.MESSAGE[2] & 0x3C);
        *MM_DATA_FRAME >>= 2;

        MM.MESSAGESIZE = 0;
        return 1;
    }

    MM.MESSAGESIZE = 0;
    return 0;
}

/*
 * INTERRUPT FUNCTION FOR IDLE DETECTION
 * EVERY NEW DATAFRAME IS DETECTED BY A LONG IDLE PERIOD WITH NO EDGES
 * EACH EDGE ON THE BUS RESETS THE DETECTION UNTIL A LONG PERIOD IS DETECTED
 */
static void MM_INTERRUPT_IDLE_ACTIVITY_DETECTION()
{
    __TIMER1_DRIVER_TCNT = 0x0000;
}

/*
 * INTERRUPT FUNCTION FOR IDLE DETECTION AND POLARITY CHECK
 * WHEN A LONG IDLE PERIOD HAS BEEN DETECTED, THIS INTERRUPT FIRES AND DETECTS THE
 * POLARITY OF THE SIGNAL WHICH IS LATER USED TO INVERT THE DATAFRAME
 * NOW THE DETECTION OF NEW DATA IS POSSIBLE
 */
static void MM_INTERRUPT_IDLE_POLARITY_DETECTION()
{
    __TIMER1_DRIVER_CLOCK_OFF();

    if(MM.MESSAGESIZE == 0)
    {
        __IO_DRIVER_INTERRUPT_INT0_SETFUNC(MM_INTERRUPT_BIT_DETECTION);
        __TIMER1_DRIVER_INTERRUPT_COMPA_SETFUNC(MM_INTERRUPT_BIT_SAMPLE_AND_SAVE);
        __TIMER1_DRIVER_INTERRUPT_COMPA_UPDATE((unsigned short)MM_SWITCH_BIT_SAMPLE_INTERVALL);
        __TIMER1_DRIVER_INTERRUPT_COMPB_UPDATE((unsigned short)MM_SWITCH_BIT_OVERSIZE_DETECT_INTERVALL);

        if(__IO_DRIVER_INTERRUPT_INT0_LEVEL())
        {
           MM.POLARITY = 0x3F;
           __IO_DRIVER_INTERRUPT_INT0_SENSE_FALLING();
        }

        else
        {
            MM.POLARITY = 0x00;
            __IO_DRIVER_INTERRUPT_INT0_SENSE_RISING();
        }

        MM.BITCOUNT = 0;
        MM.BYTECOUNT = 0;
        MM.MESSAGESIZE = 0;
        MM.TMPBYTE = 0x00;
    }

    else
    {
        MM_IDLE_MODE();
    }
}

/*
 * INTERRUPT FUNCTION FOR NEW BIT EDGE DETECTION
 */
static void MM_INTERRUPT_BIT_DETECTION()
{
    __TIMER1_DRIVER_TCNT = 0x0000;
    __TIMER1_DRIVER_CLOCK_DIV1();
}

/*
 * INTERRUPT FUNCTION FOR SAMPLING A BIT AND SAVING
 * (SAMPLES 18 BITS OR 9 TRITS IN A ROW)
 */
static void MM_INTERRUPT_BIT_SAMPLE_AND_SAVE()
{
    MM.BITCOUNT++;
    MM.TMPBYTE <<= 1;

    if((__IO_DRIVER_INTERRUPT_INT0_LEVEL()))
    {
        MM.TMPBYTE |= 0x01;
    }

    if((MM.BITCOUNT == 6) || (MM.BITCOUNT == 12) || (MM.BITCOUNT == 18))
    {
        MM.MESSAGE[(MM.BYTECOUNT)++] = MM.TMPBYTE ^ (MM.POLARITY);
        MM.TMPBYTE = 0x00;

        if(MM.BITCOUNT == 18)
        {
            __TIMER1_DRIVER_CLOCK_OFF();
            __TIMER1_DRIVER_INTERRUPT_COMPA_SETFUNC(MM_INTERRUPT_BIT_SAMPLE_AND_VERIFY);
            MM.BYTECOUNT = 0;
            MM.BITCOUNT = 0;
        }
    }
}

/*
 * INTERRUPT FUNCTION FOR SAMPLING A BIT AND COMPARE WITH THE SAVED BITS
 * THE SECOND DATAFRAME SHOULD BE IDENTICAL TO THE FIRST ONE, SO WE USE IT
 * TO VERIFY THE DATA
 * (SAMPLES 18 BITS OR 9 TRITS IN A ROW; IN CASE OF WRONG DATA -> SWITCH BACK TO IDLE MODE AND DUMP DATA)
 */
static void MM_INTERRUPT_BIT_SAMPLE_AND_VERIFY()
{
    MM.BITCOUNT++;
    MM.TMPBYTE <<= 1;

    if((__IO_DRIVER_INTERRUPT_INT0_LEVEL()))
    {
        MM.TMPBYTE |= 0x01;
    }

    if((MM.BITCOUNT == 6) || (MM.BITCOUNT == 12) || (MM.BITCOUNT == 18))
    {
        if((MM.MESSAGE[(MM.BYTECOUNT)++]) != (MM.TMPBYTE ^ MM.POLARITY))
        {
            MM_IDLE_MODE();
        }

        if(MM.BITCOUNT == 18)
        {
            __TIMER1_DRIVER_CLOCK_OFF();
            MM.MESSAGESIZE = 3;
            MM_IDLE_MODE();
        }

        MM.TMPBYTE = 0x00;
    }
}

/*
 * INTERRUPT FUNCTION FOR DETECT BIT OVERSIZE
 * IN ORDER TO DIFFERENTIATE BETWEEN TRAIN AND SWITCH COMMAND,
 * THIS INTERRUPT FIRES WHEN A BIT HAS THE WRONG SIZE AND SETS THE INTERFACE BACK TO IDLE MODE
 */
static void MM_INTERRUPT_BIT_OVERSIZED()
{
    __TIMER1_DRIVER_CLOCK_OFF();
    MM_IDLE_MODE();
}
